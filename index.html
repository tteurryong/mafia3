<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>싱글마피아 </title>
<style>
:root{--bg:#0f0f12;--card:#1b1b1f;--muted:#9aa0a6;--accent:#f6c84c;--alive:#28a745;--dead:#6c757d;}
*{box-sizing:border-box}
body{margin:0;font-family:"Malgun Gothic",system-ui,Arial;background:var(--bg);color:#eee;padding:18px;display:flex;justify-content:center}
#wrap{width:100%;max-width:1000px}
header{display:flex;justify-content:space-between;align-items:center;gap:12px}
h1{margin:0;font-size:20px}
#scoreboard{position:fixed;right:16px;top:16px;background:var(--card);padding:10px;border-radius:8px;min-width:200px;box-shadow:0 6px 18px rgba(0,0,0,0.6)}
#scoreboard h3{margin:0 0 6px 0;font-size:14px}
#game{margin-top:12px}
#controls{background:var(--card);padding:12px;border-radius:8px;display:flex;gap:10px;align-items:center;flex-wrap:wrap}
select,button,input{background:#2a2a2f;color:#eee;border:none;padding:8px 10px;border-radius:6px;cursor:pointer}
button:hover,select:hover{filter:brightness(1.08)}
#main{display:flex;gap:12px;margin-top:12px}
#left{flex:1}
#messages{background:linear-gradient(180deg,#151519,#101014);padding:12px;border-radius:8px;height:320px;overflow:auto;white-space:pre-wrap;font-size:14px;display:flex;align-items:center;justify-content:center}
#players{margin-top:10px;display:flex;flex-wrap:wrap;gap:8px}
.playerCard{display:flex;align-items:center;gap:8px;background:#26262a;padding:8px;border-radius:8px;min-width:140px}
.avatar{width:24px;height:24px;background:#222;border-radius:4px;image-rendering:pixelated}
.playerInfo{font-size:14px}
.badge{font-size:12px;padding:3px 6px;border-radius:999px;background:#333;color:#ddd;margin-left:6px}
.dead{background:var(--dead);color:#ddd;text-decoration:line-through}
.you{outline:3px solid rgba(246,200,76,0.12)}
#right{width:320px}
#inputSection{margin-top:12px;background:var(--card);padding:10px;border-radius:8px;min-height:140px}
.small{font-size:13px;color:var(--muted)}
#reveal{background:linear-gradient(90deg,#262626,#1a1a1a);padding:10px;border-radius:8px;margin-top:10px;display:none}
.footerNote{margin-top:8px;color:var(--muted);font-size:13px}
</style>
</head>
<body>
<div id="wrap">
  <header>
    <h1>싱글마피아 </h1>
    <div class="small">의사: 자기 치료 가능 · 경찰: 시작시 공개 · 경찰 조사 즉시 공개 · 로그 한 줄씩 3초</div>
  </header>

  <div id="scoreboard">
    <h3>점수판</h3>
    <div id="scoreList">-</div>
  </div>

  <div id="game">
    <div id="controls">
      참가 인원:
      <select id="playerCount"></select>
      <button id="startBtn">게임 시작</button>
      <button id="quickBtn">빠른시작(8명)</button>
      <button id="resetScoreBtn" title="브라우저에 저장된 점수 초기화">점수 초기화</button>
      <div class="small">당신은 항상 1번 플레이어입니다.</div>
    </div>

    <div id="main">
      <div id="left">
        <div id="messages">(로그가 여기 한 줄씩 3초 간격으로 표시됩니다)</div>
        <div id="players"></div>
        <div id="inputSection"></div>
      </div>

      <div id="right">
        <div id="reveal"><strong>게임 결과 — 역할 공개</strong><div id="revealList"></div></div>
        <div class="footerNote">종료 후 '다시 시작'으로 새 게임 가능. 점수는 브라우저(LocalStorage)에 누적됩니다.</div>
      </div>
    </div>
  </div>
</div>

<script>
/* ---------- 세팅 & 유틸 ---------- */
const playerCountSelect = document.getElementById('playerCount');
for(let i=5;i<=12;i++){ const o=document.createElement('option'); o.value=i; o.textContent=i+'명'; playerCountSelect.appendChild(o); }
const startBtn = document.getElementById('startBtn');
const quickBtn = document.getElementById('quickBtn');
const resetScoreBtn = document.getElementById('resetScoreBtn');
const messages = document.getElementById('messages');
const playersDiv = document.getElementById('players');
const inputSection = document.getElementById('inputSection');
const revealBox = document.getElementById('reveal');
const revealList = document.getElementById('revealList');
const scoreList = document.getElementById('scoreList');

let scores = {};
const SCORE_KEY = 'singlemafia_scores_v3';
function loadScores(){ try{ const s=localStorage.getItem(SCORE_KEY); if(s) scores=JSON.parse(s); }catch(e){} }
function saveScores(){ try{ localStorage.setItem(SCORE_KEY, JSON.stringify(scores)); }catch(e){} }
function ensureScores(n){ for(let i=0;i<n;i++) if(scores[i]===undefined) scores[i]=0; renderScores(); }
function renderScores(){ const ids=Object.keys(scores).map(x=>parseInt(x)).sort((a,b)=>a-b); let html=''; ids.forEach(id=> html+=`플레이어 ${id+1}: ${scores[id]}점<br/>`); scoreList.innerHTML = html || '-'; }
resetScoreBtn.onclick = ()=>{ if(confirm('저장된 점수를 모두 초기화할까요?')){ scores={}; saveScores(); renderScores(); } };

loadScores(); renderScores();

/* 메시지 큐: 한 줄씩 3초 유지 */
let _msgQueue = [];
function logLine(text, clear=false){
  if(clear){
    _msgQueue = [];
    if(_msgTimer){ clearTimeout(_msgTimer); _msgTimer=null; }
    messages.textContent = '';
  }
  // _msgQueue.push('' + text);  // 이 부분 삭제
  // _processMsgQueue();         // 이 부분 삭제

  // 그냥 바로 전체 메시지를 한 번에 보여주기
  messages.textContent += text + '\n';
                     }

/* 작은 유틸 */
function mkBtn(lbl, cb){ const b=document.createElement('button'); b.textContent=lbl; b.onclick=cb; return b; }
function pickRandom(arr){ return arr.length? arr[Math.floor(Math.random()*arr.length)] : null; }

/* ---------- 역할/팀/배분 ---------- */
const TEAM = { MAFIA:'mafia', TOWN:'town', NEUTRAL:'neutral' };
const ROLES = {
  마피아:{team:TEAM.MAFIA},
  스파이:{team:TEAM.MAFIA},
  훈련사:{team:TEAM.MAFIA},
  경찰:{team:TEAM.TOWN},
  의사:{team:TEAM.TOWN},
  간호사:{team:TEAM.TOWN},
  판사:{team:TEAM.TOWN},
  정치인:{team:TEAM.TOWN},
  기자:{team:TEAM.TOWN},
  군인:{team:TEAM.TOWN},
  무당:{team:TEAM.TOWN},
  탐정:{team:TEAM.TOWN},
  테러범:{team:TEAM.NEUTRAL}
};
const SUPPORT_POOL = ['스파이','훈련사'];
const SPECIAL_POOL = ['판사','정치인','기자','군인','무당','탐정','간호사','테러범'];

function buildRolesByRule(n){
  let mafiaCore=1, support=0, police=1, doctor=1;
  if(n<=5){ mafiaCore=1; support=0; police=1; doctor=1; }
  else if(n<=7){ mafiaCore=1; support=1; police=1; doctor=1; }
  else if(n===8){ mafiaCore=2; support=1; police=1; doctor=2; }
  else if(n>=9 && n<=11){ mafiaCore=2; support=1; police=1; doctor=2; }
  else { mafiaCore=3; support=1; police=1; doctor=2; }
  const roles=[];
  for(let i=0;i<mafiaCore;i++) roles.push('마피아');
  if(support) roles.push(SUPPORT_POOL[Math.floor(Math.random()*SUPPORT_POOL.length)]);
  for(let i=0;i<police;i++) roles.push('경찰');
  for(let i=0;i<doctor;i++) roles.push('의사');
  const pool=[...SPECIAL_POOL];
  while(roles.length<n && pool.length){ const idx=Math.floor(Math.random()*pool.length); roles.push(pool.splice(idx,1)[0]); }
  while(roles.length<n){ roles.push(SPECIAL_POOL[Math.floor(Math.random()*SPECIAL_POOL.length)]); }
  for(let i=roles.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [roles[i],roles[j]]=[roles[j],roles[i]]; }
  return roles;
}

/* ---------- 게임 상태 ---------- */
let game = null;
function alivePlayers(){ return game.players.filter(p=>p.alive); }
function teamOf(p){ return ROLES[p.role].team; }

/* avatar 그리기 (간단) */
function drawAvatar(container, seed, role, alive){
  const size=8, scale=3, cv=document.createElement('canvas');
  cv.width=size; cv.height=size; cv.style.width=(size*scale)+'px'; cv.style.height=(size*scale)+'px'; cv.className='avatar';
  const ctx = cv.getContext('2d');
  function rnd(n){ const x=Math.sin(seed*1234 + n*2654435761) * 10000; return Math.abs(x%1); }
  const base = Math.floor(rnd(1)*360);
  for(let y=0;y<size;y++) for(let x=0;x<size;x++){
    const v = rnd(x*size+y) > 0.5;
    let color = '#222';
    if(v){
      if(role==='마피아') color = `hsl(${(base+0)%360} 70% 50%)`;
      else if(role==='경찰') color = `hsl(${(base+120)%360} 70% 50%)`;
      else if(role==='의사') color = `hsl(${(base+60)%360} 70% 50%)`;
      else color = `hsl(${(base+200)%360} 60% 45%)`;
    } else color = '#0b0b0b';
    ctx.fillStyle = color; ctx.fillRect(x,y,1,1);
  }
  if(!alive){ ctx.fillStyle='rgba(0,0,0,0.7)'; ctx.fillRect(0,0,size,size); ctx.fillStyle='rgba(255,255,255,0.9)'; ctx.font='6px monospace'; ctx.fillText('X',2,6); }
  container.appendChild(cv);
}

function renderPlayers(){
  playersDiv.innerHTML = '';
  game.players.forEach(p=>{
    const card = document.createElement('div'); card.className='playerCard';
    const avwrap=document.createElement('div'); avwrap.style.width='36px';
    drawAvatar(avwrap, p.id+7, p.role, p.alive);
    const info=document.createElement('div'); info.className='playerInfo';
    const title=document.createElement('div'); title.textContent = (p.id+1) + (p.id===0? ' (당신)':'');
    const badge=document.createElement('span'); badge.className='badge'; badge.textContent = p.alive ? '생존' : '사망';
    title.appendChild(badge);
    const sub=document.createElement('div'); sub.className='small'; sub.style.color='#bfbfbf';
    sub.textContent = ''; // 의심표시 없음
    info.appendChild(title); info.appendChild(sub);
    if(!p.alive) card.classList.add('dead');
    if(p.id===0) card.classList.add('you');
    card.appendChild(avwrap); card.appendChild(info);
    playersDiv.appendChild(card);
  });
}

/* ---------- 시작 ---------- */
startBtn.onclick = ()=> startGame(parseInt(playerCountSelect.value));
quickBtn.onclick = ()=>{ playerCountSelect.value = 8; startGame(8); };

function startGame(n){
  const roles = buildRolesByRule(n);
  game = {
    players: roles.map((r,i)=>({ id:i, role:r, alive:true, flags:{ blockedUntilDay:0, soldierArmor:(r==='군인'), usedSoldierShot:false }})),
    day:0, night:0, phase:'night',
    spyKnown:[], trainerPickCount:{}, nightActs:{},
    journalistReveal:null, detectiveMsg:null,
    suspicion:{}, lastVotes:{}, soldierShotAvailable:false,
    policeInvestigated: new Set()
  };
  ensureScores(n);
  renderPlayers();
  // 경찰 위치 공개(첫날부터)
  const police = game.players.find(p=>p.role==='경찰');
  if(police) logLine(`(공지) 경찰은 ${police.id+1}번 플레이어입니다.`, true);
  else logLine('(공지) 이번 게임에 경찰 역할이 없습니다.', true);
  // 마피아 동료 알려주기(플레이어가 마피아면)
  const myRole = game.players[0].role;
  if(myRole === '마피아'){
    const mafiaIds = game.players.filter(p=>p.role==='마피아' && p.id!==0).map(p=>p.id);
    logLine(mafiaIds.length? `(비밀) 당신의 마피아 동료: ${mafiaIds.map(x=>x+1).join(', ')}번` : '(비밀) 당신은 유일한 마피아입니다.');
  } else if(myRole === '스파이' || myRole === '훈련사'){
    // 보조직업이면 마피아 팀 DM 가능 - (간단히 알림)
    // (세부 DM 기능은 간단화)
  }
  setTimeout(()=> nextPhase('night'), 700);
}

function nextPhase(phase){
  game.phase = phase;
  inputSection.innerHTML = '';
  if(phase==='night') nightPhase();
  else if(phase==='day') dayPhase();
  else if(phase==='end') endPhase();
}

/* ---------- NIGHT ---------- */
function canUseAbility(p){ if(!p.alive) return false; if(game.day < p.flags.blockedUntilDay) return false; return true; }

function nightPhase(){
  game.night++; game.nightActs = {}; game.journalistReveal = null; game.detectiveMsg = null;
  logLine(`\n🌙 밤 ${game.night} 시작`);
  renderPlayers();

  if(!game.players[0].alive){ logLine('당신은 사망해 밤 행동 없음.'); return setTimeout(aiNightActions,700); }

  const me = game.players[0];
  const alive = alivePlayers();

  const addButtons=(label,cb,filterFn=()=>true)=>{
    const wrap=document.createElement('div'); wrap.innerHTML = `<div class="small">${label}</div>`;
    alive.filter(x=>x.id!==me.id && filterFn(x)).forEach(t=>{
      const b = mkBtn((t.id+1)+'번', ()=>{ cb(t.id); inputSection.innerHTML=''; logLine(`${me.role}이 ${t.id+1}번을 선택했습니다.`); setTimeout(aiNightActions,400); });
      wrap.appendChild(b);
    });
    inputSection.appendChild(wrap);
  };

  if(me.role==='마피아'){
    logLine('당신(마피아)은 공격 대상을 고르세요.');
    addButtons('공격 대상', id => game.nightActs.mafiaKill = id, p=> teamOf(p)!==TEAM.MAFIA);
  } else if(me.role==='스파이'){
    logLine('당신(스파이)은 직업 탐지 대상을 고르세요.');
    addButtons('탐지 대상', id => game.nightActs.spyPeek = id);
    if(isSpySoloActive()) addButtons('스파이 단독 공격', id => game.nightActs.spyKill = id);
  } else if(me.role==='훈련사'){
    logLine('당신(훈련사)은 봉인 대상을 고르세요.');
    addButtons('봉인 대상', id => game.nightActs.trainerBlock = id);
    if(isTrainerSoloActive()) addButtons('훈련사 단독 공격', id => game.nightActs.trainerKill = id);
  } else if(me.role==='의사' || (me.role==='간호사' && nurseActing())){
    logLine(`당신(${me.role})은 치료 대상을 고르세요. (자기 자신 포함)`);
    const wrap=document.createElement('div'); wrap.innerHTML='<div class="small">치료 대상</div>';
    alive.forEach(t=>{
      const b = mkBtn((t.id+1)+'번', ()=>{ game.nightActs.heal = t.id; inputSection.innerHTML=''; logLine(`${me.role}이 ${t.id+1}번을 치료 대상으로 선택했습니다.`); setTimeout(aiNightActions,400); });
      wrap.appendChild(b);
    });
    inputSection.appendChild(wrap);
  } else if(me.role==='경찰'){
    logLine('당신(경찰)은 조사 대상을 고르세요.');
    addButtons('조사 대상', id => { game.nightActs.policeCheck = id; });
  } else if(me.role==='탐정'){
    logLine('당신(탐정)은 추적 대상을 고르세요.');
    addButtons('추적 대상', id => { game.nightActs.detectiveTrack = id; });
  } else if(me.role==='군인' && game.soldierShotAvailable && !me.flags.usedSoldierShot){
    logLine('당신(군인)은 1회 사격이 가능합니다.');
    addButtons('사격 대상', id => { game.nightActs.soldierShot = id; me.flags.usedSoldierShot=true; game.soldierShotAvailable=false; });
  } else {
    logLine(`당신(${me.role})은 밤 행동 없음.`);
    setTimeout(aiNightActions,600);
  }
}

function nurseActing(){ const docAlive = game.players.some(p=>p.role==='의사' && p.alive); const nurse = game.players.find(p=>p.role==='간호사' && p.alive); return nurse && !docAlive; }
function isSpySoloActive(){ const spy = game.players.find(p=>p.role==='스파이' && p.alive); if(!spy) return false; const mafiaAlive = alivePlayers().filter(p=> teamOf(p)===TEAM.MAFIA && p.role!=='스파이' && p.role!=='훈련사'); return mafiaAlive.length===0; }
function isTrainerSoloActive(){ const tr = game.players.find(p=>p.role==='훈련사' && p.alive); if(!tr) return false; const mafiaAlive = alivePlayers().filter(p=> teamOf(p)===TEAM.MAFIA && p.role!=='스파이' && p.role!=='훈련사'); return mafiaAlive.length===0; }

/* ---------- AI 밤 행동 (간단·안정적) ---------- */
function aiNightActions(){
  const alive = alivePlayers();
  const A = game.nightActs;

  // MAfIA main group attack
  if(A.mafiaKill == null){
    const mafiaGroup = alive.filter(p=> teamOf(p)===TEAM.MAFIA && p.role==='마피아');
    if(mafiaGroup.length){
      // prefer police/important roles
      let best=null, bestScore=-1e9;
      alive.filter(p=> teamOf(p)!==TEAM.MAFIA).forEach(c=>{
        let s = 0;
        if(c.role==='경찰') s+=60;
        if(c.role==='의사' || c.role==='간호사') s+=40;
        if(c.role==='판사') s+=30;
        s += (game.suspicion[c.id]||0);
        s += Math.random()*6;
        if(s>bestScore){ bestScore=s; best=c; }
      });
      if(best) A.mafiaKill = best.id;
    } else {
      // no mafia left -> try spy/trainer single attacks
      if(isSpySoloActive() && A.spyKill==null){ const t = pickRandom(alive.filter(x=> x.role!=='스파이')); if(t) A.spyKill = t.id; }
      if(isTrainerSoloActive() && A.trainerKill==null){ const t = pickRandom(alive.filter(x=> x.role!=='훈련사')); if(t) A.trainerKill = t.id; }
    }
  }

  // spy peek
  if(A.spyPeek==null){
    const spyAi = alive.find(p=>p.role==='스파이' && p.id!==0);
    if(spyAi && canUseAbility(spyAi)){
      const t = pickRandom(alive.filter(x=> x.id!==spyAi.id));
      if(t) A.spyPeek = t.id;
    }
  }

  // trainer block
  if(A.trainerBlock==null){
    const tr = alive.find(p=>p.role==='훈련사' && p.id!==0);
    if(tr && canUseAbility(tr)){
      const t = pickRandom(alive.filter(x=> x.id!==tr.id));
      if(t) A.trainerBlock = t.id;
    }
  }

  // doctors
  if(A.heal==null){
    const docs = alive.filter(p=> (p.role==='의사' || (p.role==='간호사' && nurseActing())) && p.id!==0);
    if(docs.length){
      // prefer police else self
      let target = alive.find(x=> x.role==='경찰') || docs[0];
      if(target) A.heal = target.id;
    }
  }

  // police check
  if(A.policeCheck==null){
    const cops = alive.filter(p=> p.role==='경찰' && p.id!==0);
    if(cops.length){
      const cp = cops[0];
      const t = pickRandom(alive.filter(x=> x.id!==cp.id));
      if(t) A.policeCheck = t.id;
    }
  }

  // journalist
  if(A.journalistTarget==null){
    const jr = alive.find(p=>p.role==='기자' && p.id!==0);
    if(jr && (game.night%2===0)) {
      const t = pickRandom(alive.filter(x=> x.id!==jr.id));
      if(t) A.journalistTarget = t.id;
    }
  }

  // detective
  if(A.detectiveTrack==null){
    const dt = alive.find(p=> p.role==='탐정' && p.id!==0);
    if(dt){
      const t = pickRandom(alive.filter(x=> x.id!==dt.id));
      if(t) A.detectiveTrack = t.id;
    }
  }

  setTimeout(resolveNight, 700);
}

/* ---------- 밤 해결 ---------- */
function resolveNight(){
  const A = game.nightActs;
  const kills = new Set();

  // trainer block: block until game.day + 2 (so next day+night blocked)
  if(A.trainerBlock!=null){
    const trg = game.players[A.trainerBlock];
    if(trg){
      trg.flags.blockedUntilDay = Math.max(trg.flags.blockedUntilDay, game.day + 2);
      game.trainerPickCount[trg.id] = (game.trainerPickCount[trg.id] || 0) + 1;
      if(ROLES[trg.role].team === TEAM.MAFIA){
        // contact -> (simple) write a private line for "mafia team" by logging a system message (we keep it public but marked)
        logLine(`[접선-훈련사] ${trg.id+1}번이 마피아로 확인됨(접선).`);
      } else {
        // optionally log trainer info privately - but we'll log a generic note
        // no public leak to players for now
      }
    }
  }

  // spy peek
  if(A.spyPeek!=null){
    const s = game.players[A.spyPeek];
    if(s){
      if(ROLES[s.role].team === TEAM.MAFIA){
        logLine(`[접선-스파이] ${s.id+1}번이 마피아로 접선됨.`);
      } else {
        // record spy-known
        game.spyKnown.push({id:s.id, role:s.role});
        logLine(`[스파이] ${s.id+1}번은 ${s.role}입니다.`);
        // reduce suspicion a bit if proven town
        game.suspicion[s.id] = (game.suspicion[s.id]||0) - 10;
      }
    }
  }

  // police check -> immediately public result
  if(A.policeCheck!=null){
    const t = game.players[A.policeCheck];
    if(t){
      const isMafia = (teamOf(t)===TEAM.MAFIA);
      logLine(`경찰 조사 결과: ${t.id+1}번은 ${isMafia? '마피아입니다!':'마피아가 아닙니다.'}`);
      game.policeInvestigated.add(t.id);
      game.suspicion[t.id] = (game.suspicion[t.id]||0) + (isMafia? 50 : -20);
    }
  }

  // soldier shot
  if(A.soldierShot!=null){
    const t = game.players[A.soldierShot];
    if(t && t.alive){ kills.add(t.id); logLine(`군인이 ${t.id+1}번을 사격했습니다.`); }
  }

  // determine victim by mafia/spykill/trainerkill
  let victim = null;
  if(A.mafiaKill!=null) victim = game.players[A.mafiaKill];
  else if(A.spyKill!=null) victim = game.players[A.spyKill];
  else if(A.trainerKill!=null) victim = game.players[A.trainerKill];

  if(victim){
    // if healed -> survive
    if(A.heal === victim.id){
      logLine(`${victim.id+1}번은 치료로 생존했습니다.`);
    } else if(victim.role==='군인' && victim.flags.soldierArmor){
      victim.flags.soldierArmor = false;
      logLine(`군인(${victim.id+1})이 방탄으로 생존했습니다.`);
    } else {
      // if victim is 테러범 -> companion explosion
      if(victim.role==='테러범'){
        const mafiaAlive = alivePlayers().filter(p=> teamOf(p)===TEAM.MAFIA);
        if(mafiaAlive.length){
          const m = pickRandom(mafiaAlive);
          if(m) { kills.add(m.id); logLine(`테러범(${victim.id+1}) 자폭! 마피아(${m.id+1})가 함께 사망.`); }
        }
      }
      kills.add(victim.id);
      logLine(`${victim.id+1}번이 밤에 사망했습니다.`);
    }
  } else {
    logLine('밤 공격이 없었습니다.');
  }

  // apply kills (mark firstDeathRole if applicable)
  kills.forEach(id => {
    if(game.players[id] && game.players[id].alive) {
      game.players[id].alive = false;
      if(!game.firstDeathRole) game.firstDeathRole = game.players[id].role;
    }
  });

  // Unify shaman (무당) morph: if first death exists, first living 무당 becomes that role
  if(game.firstDeathRole){
    const shaman = game.players.find(p=> p.role==='무당' && p.alive);
    if(shaman && !shaman.flags.morphed){
      shaman.role = game.firstDeathRole;
      shaman.flags.morphed = true;
      logLine(`무당이 첫 사망자의 직업(${game.firstDeathRole})을 계승했습니다.`);
    }
  }

  // police death -> enable soldier shot
  const anyPolice = game.players.some(p=> p.role==='경찰');
  const policeAlive = alivePlayers().some(p=> p.role==='경찰');
  if(anyPolice && !policeAlive && !game._policeWasDead){
    game.soldierShotAvailable = true;
    logLine('경찰이 모두 사망했습니다. 군인이 1회 사격 가능합니다.');
  }
  game._policeWasDead = !policeAlive;

  // journalist reveal (if set)
  if(A.journalistTarget!=null){
    const t = game.players[A.journalistTarget];
    if(t){
      game.journalistReveal = `기자: ${t.id+1}번은 ${t.role}입니다.`;
      logLine(game.journalistReveal);
      if(teamOf(t)===TEAM.MAFIA) game.suspicion[t.id] = (game.suspicion[t.id]||0) + 35;
      else game.suspicion[t.id] = (game.suspicion[t.id]||0) - 8;
    }
  }

  // detective reveal (ability usage)
  if(A.detectiveTrack!=null){
    const tracked = A.detectiveTrack;
    const used = game._usedByThisNight && game._usedByThisNight.has(tracked);
    game.detectiveMsg = used ? `탐정: ${tracked+1}번은 전날 밤 능력을 사용했습니다.` : `탐정: ${tracked+1}번은 전날 밤 능력을 사용하지 않았습니다.`;
    logLine(game.detectiveMsg);
    if(used) game.suspicion[tracked] = (game.suspicion[tracked]||0) + 6;
  }

  renderPlayers();

  if(!game.players[0].alive) logLine('당신이 사망했습니다. 게임 자동 진행됩니다.');

  if(checkWin()) return setTimeout(()=> nextPhase('end'), 900);
  setTimeout(()=> nextPhase('day'), 900);
}

/* ---------- DAY ---------- */
function dayPhase(){
  game.day++;
  logLine(`\n☀ 낮 ${game.day} 시작`);
  // journalist and detective already logged in night resolution if applicable (we also keep these optionally)
  renderPlayers();

  const alive = alivePlayers();
  const judge = alive.find(p=> p.role==='판사');
  const playerAlive = game.players[0].alive;

  if(judge){
    logLine('판사가 생존합니다 — 일반 투표는 무시되고 판사가 처형자를 지정합니다. (판사/정치인은 투표 면역)');
    if(playerAlive && game.players[0].role==='판사'){
      inputSection.innerHTML='';
      alive.filter(x=> x.id!==0).forEach(t=> inputSection.appendChild(mkBtn(`${t.id+1}번 처형`, ()=>{ executeByJudge(t.id); })));
    } else {
      setTimeout(()=> aiJudgeExecute(judge.id), 900);
    }
    return;
  }

  // 일반투표
  if(!playerAlive){
    logLine('당신은 죽어 투표 불가. AI가 투표를 진행합니다.');
    setTimeout(()=> aiVoteResolve(null), 900);
  } else {
    inputSection.innerHTML = '<div class="small">누구를 처형할까요? (본인 제외) — 정치인/판사는 투표로 죽지 않음</div>';
    alive.filter(p=> p.id!==0).forEach(p=> inputSection.appendChild(mkBtn(`${p.id+1}번`, ()=>{ inputSection.innerHTML=''; aiVoteResolve(p.id); })));
  }
}

/* 판사 처형 */
function executeByJudge(tid){
  const t = game.players[tid];
  if(!t || !t.alive) return;
  if(t.role==='판사'){ logLine('판사는 스스로를 처형할 수 없습니다.'); return; }
  t.alive=false; logLine(`판사가 ${t.id+1}번을 처형했습니다.`);
  if(t.role==='테러범'){
    const r = pickRandom(alivePlayers());
    if(r){ r.alive=false; logLine(`테러범(${t.id+1})가 무작위(${r.id+1})를 동반 처형했습니다.`); }
  }
  renderPlayers();
  if(checkWin()) setTimeout(()=> nextPhase('end'),800); else setTimeout(()=> nextPhase('night'),800);
}
function aiJudgeExecute(judgeId){
  const cand = alivePlayers().filter(p=> p.id!==judgeId);
  if(!cand.length) return setTimeout(()=> nextPhase('night'),600);
  const t = pickRandom(cand);
  executeByJudge(t.id);
}

/* ---------- 투표 (스마트화된 AI) ---------- */
function candidateScoreFor(voter, target){
  if(!target.alive) return -1e9;
  if(voter.id === target.id) return -1e9;
  const immune = (target.role==='정치인' || target.role==='판사');
  let s = 0;
  if(teamOf(voter)===TEAM.MAFIA){
    s += (target.role==='경찰')? 50 : (target.role==='의사'||target.role==='간호사')? 30 : 10;
  } else if(teamOf(voter)===TEAM.TOWN){
    s += (game.suspicion[target.id]||0);
    s += (target.role==='마피아'||target.role==='스파이'||target.role==='훈련사')? 15 : 0;
  } else {
    s += (target.role==='경찰' || target.role==='의사')? 12 : 5;
  }
  const beenVotedBy = Object.entries(game.lastVotes).filter(([voterId,tid])=> parseInt(voterId)===target.id && tid===voter.id);
  if(beenVotedBy.length) s += 4;
  if(immune) s -= 25;
  s += Math.random()*3;
  return s;
}

function aiVoteResolve(myPick){
  const votes = {};
  function addVote(id, w=1){ votes[id] = (votes[id]||0) + w; }
  const alive = alivePlayers();

  if(myPick != null){
    addVote(myPick, (game.players[0].role==='정치인'?2:1));
    game.lastVotes[0] = myPick;
  }

  alive.forEach(voter=>{
    if(voter.id===0) return;
    let best=null, bestS=-1e9;
    alive.forEach(target=>{
      if(target.id===voter.id) return;
      const s = candidateScoreFor(voter, target);
      if(s>bestS){ bestS=s; best=target; }
    });
    if(best) { addVote(best.id, (voter.role==='정치인'?2:1)); game.lastVotes[voter.id]=best.id; }
  });

  // 마피아는 치밀하게 한 후보로 몰리는 경향
  const mafiaVoters = alive.filter(p=> teamOf(p)===TEAM.MAFIA);
  if(mafiaVoters.length){
    // 가장많은 표 받은 후보에게 추가 동조
    let leader=null, max=0;
    for(const [id,c] of Object.entries(votes)){ if(c>max){ max=c; leader=parseInt(id); } }
    if(leader!=null){
      mafiaVoters.forEach(mv=>{
        if(game.lastVotes[mv.id] !== leader){
          addVote(leader, (mv.role==='정치인'?2:1));
        }
      });
    }
  }

  // 출력
  logLine('\n투표 집계:');
  for(const [id,c] of Object.entries(votes)) logLine(`${parseInt(id)+1}번: ${c}표`);

  // decide
  let max=0, winners=[];
  for(const [id,c] of Object.entries(votes)){ if(c>max){ max=c; winners=[parseInt(id)]; } else if(c===max){ winners.push(parseInt(id)); } }
  if(winners.length===1){
    const t = game.players[winners[0]];
    if(t.role==='정치인' || t.role==='판사'){
      logLine(`낮: ${t.role}(${t.id+1})은 투표로 죽지 않습니다.`);
    } else {
      t.alive=false;
      logLine(`낮: ${t.id+1}번이 처형되었습니다.`);
      if(t.role==='테러범'){
        const r = pickRandom(alivePlayers());
        if(r){ r.alive=false; logLine(`테러범(${t.id+1})가 무작위(${r.id+1})를 동반 사망시켰습니다.`); }
      }
      const isM = (teamOf(t)===TEAM.MAFIA);
      alivePlayers().forEach(p=> { if(p.id!==t.id) game.suspicion[p.id] = (game.suspicion[p.id]||0) + (isM? -2 : 1); });
    }
  } else {
    logLine('낮: 동점/무효로 처형 없음.');
  }

  renderPlayers();
  if(checkWin()) setTimeout(()=> nextPhase('end'),900); else setTimeout(()=> nextPhase('night'),900);
}

/* ---------- 승리 / 종료 / 점수 ---------- */
function checkWin(){
  const alive = alivePlayers();
  const mafiaAlive = alive.filter(p=> teamOf(p)===TEAM.MAFIA).length;
  const townAlive = alive.filter(p=> teamOf(p)===TEAM.TOWN).length;
  if(mafiaAlive===0){ logLine('\n🎉 타운 승리!'); applyScores('town'); return true; }
  if(mafiaAlive >= townAlive && mafiaAlive>0){ logLine('\n💀 마피아 승리!'); applyScores('mafia'); return true; }
  return false;
}
function applyScores(winner){
  game.players.forEach(p=>{
    if(scores[p.id]===undefined) scores[p.id]=0;
    const team = teamOf(p);
    if(team === winner) scores[p.id] += 10;
    else scores[p.id] -= 2;
  });
  renderScores(); saveScores();
}
function endPhase(){
  logLine('\n=== 게임 종료 — 역할 공개 ===', true);
  revealBox.style.display='block';
  let html = '';
  game.players.forEach(p=> html += `${p.id+1}번: ${p.role} (${p.alive? '생존':'사망'})<br/>`);
  revealList.innerHTML = html;
  inputSection.innerHTML = '<div style="text-align:center;margin-top:10px;"><button id="restart">다시 시작</button></div>';
  document.getElementById('restart').onclick = ()=> location.reload();
  renderPlayers();
}

/* ---------- 헬퍼: 랜덤, pickRandom wrapper ---------- */
function pickRandom(arr){ return arr && arr.length? arr[Math.floor(Math.random()*arr.length)] : null; }

</script>
</body>
</html>
