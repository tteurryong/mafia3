<!DOCTYPE html><html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>싱글마피아 </title>
<style>
:root{--bg:#0f0f12;--card:#1b1b1f;--muted:#9aa0a6;--accent:#f6c84c;--alive:#28a745;--dead:#6c757d;--ink:#e6e9ef}
*{box-sizing:border-box}
body{margin:0;font-family:"Malgun Gothic",system-ui,Arial;background:var(--bg);color:#eee;padding:18px;display:flex;justify-content:center}
#wrap{width:100%;max-width:1200px}
header{display:flex;justify-content:space-between;align-items:center;gap:12px}
h1{margin:0;font-size:20px}
#scoreboard{position:fixed;right:16px;top:16px;background:var(--card);padding:10px;border-radius:8px;min-width:220px;box-shadow:0 6px 18px rgba(0,0,0,0.6)}
#scoreboard h3{margin:0 0 6px 0;font-size:14px}
#scoreboard .mini{font-size:12px;color:var(--muted);margin-bottom:6px}
#game{margin-top:12px}
#controls{background:var(--card);padding:12px;border-radius:8px;display:flex;gap:10px;align-items:center;flex-wrap:wrap}
select,button,input{background:#2a2a2f;color:#eee;border:none;padding:8px 10px;border-radius:6px;cursor:pointer}
button:hover,select:hover{filter:brightness(1.08)}
#main{display:grid;grid-template-columns:1fr 360px 320px;gap:12px;margin-top:12px}
#left{min-width:0}
#messages{background:linear-gradient(180deg,#151519,#101014);padding:12px;border-radius:8px;min-height:360px;max-height:680px;overflow:auto;white-space:pre-wrap;font-size:14px}
#players{margin-top:10px;display:flex;flex-wrap:wrap;gap:8px}
.playerCard{display:flex;align-items:center;gap:8px;background:#26262a;padding:8px;border-radius:8px;min-width:160px}
.avatar{width:24px;height:24px;background:#222;border-radius:4px;image-rendering:pixelated}
.playerInfo{font-size:14px}
.badge{font-size:12px;padding:3px 6px;border-radius:999px;background:#333;color:#ddd;margin-left:6px}
.dead{background:var(--dead);color:#ddd;text-decoration:line-through}
.you{outline:3px solid rgba(246,200,76,0.12)}
#middle{min-width:0}
#inputSection{margin-top:12px;background:var(--card);padding:10px;border-radius:8px;min-height:140px}
.small{font-size:13px;color:var(--muted)}
#right{min-width:0}
#reveal{background:linear-gradient(90deg,#262626,#1a1a1a);padding:10px;border-radius:8px;margin-top:10px;display:none}
.footerNote{margin-top:8px;color:var(--muted);font-size:13px}
.warn{background:#33250a;border:1px solid #664a0e;color:#ffd98a;border-radius:8px;padding:8px;margin-bottom:8px}
.pill{display:inline-block;background:#303036;border:1px solid #45454e;border-radius:999px;padding:3px 8px;margin-right:6px;font-size:12px;color:#cbd3ff}
/* 비밀창 */
#dmPanel{background:var(--card);border-radius:8px;padding:8px;display:flex;flex-direction:column;gap:8px}
#dmHeader{display:flex;gap:6px;flex-wrap:wrap;align-items:center}
#dmTabs{display:flex;gap:6px;flex-wrap:wrap}
.dmTab{background:#2a2a2f;border:1px solid #3a3a42;border-radius:999px;padding:4px 10px;font-size:12px;cursor:pointer}
.dmTab.active{background:#3b3b46;border-color:#6d6d7a}
#dmLog{background:#0f1014;border:1px solid #2a2a34;min-height:220px;max-height:320px;overflow:auto;border-radius:8px;padding:8px;white-space:pre-wrap;font-size:13px}
#dmInputRow{display:flex;gap:6px}
#dmInput{flex:1}
.system{color:#9bb4ff}
.me{color:#a6e3a1}
.them{color:#f2cdcd}
.roletag{color:#ffd399}
</style>
</head>
<body>
<div id="wrap">
  <header>
    <h1>싱글마피아 — </h1>
    <div class="small">의심표시 없음 · 신규 직업/규칙 · 스마트 투표 · 비밀창 · 점수 누적</div>
  </header>  <div id="scoreboard">
    <h3>점수판</h3>
    <div class="mini">세션+브라우저 로컬에 누적 저장</div>
    <div id="scoreList">-</div>
  </div>  <div id="game">
    <div id="controls">
      참가 인원:
      <select id="playerCount"></select>
      <button id="startBtn">게임 시작</button>
      <button id="quickBtn">빠른시작(8명)</button>
      <button id="resetScoreBtn" title="브라우저에 저장된 점수 초기화">점수 초기화</button>
      <div class="small">당신은 항상 1번 플레이어입니다.</div>
    </div><div id="main">
  <div id="left">
    <div id="messages"></div>
    <div id="players"></div>
    <div id="inputSection"></div>
  </div>

  <div id="middle">
    <div id="dmPanel">
      <div id="dmHeader">
        <span class="small">비밀창 (개인/팀 접선 공유)</span>
        <div id="dmTabs"></div>
      </div>
      <div id="dmLog"></div>
      <div id="dmInputRow">
        <input id="dmInput" placeholder="메시지 입력 (보낼 수 있는 방에만 전송 가능)"/>
        <button id="dmSendBtn">보내기</button>
      </div>
    </div>
    <div id="reveal"><strong>게임 결과 — 역할 공개</strong><div id="revealList"></div></div>
  </div>

  <div id="right">
    <div class="footerNote">종료 후 '다시 시작'으로 새 게임 가능. 점수는 브라우저(LocalStorage)에 누적됩니다.</div>
  </div>
</div>

  </div>
</div><script>
/* ---------- 초기 세팅 ---------- */
const playerCountSelect = document.getElementById('playerCount');
for(let i=5;i<=12;i++){ const o=document.createElement('option'); o.value=i; o.textContent=i+'명'; playerCountSelect.appendChild(o); }
const startBtn = document.getElementById('startBtn');
const quickBtn = document.getElementById('quickBtn');
const resetScoreBtn = document.getElementById('resetScoreBtn');
const messages = document.getElementById('messages');
const playersDiv = document.getElementById('players');
const inputSection = document.getElementById('inputSection');
const revealBox = document.getElementById('reveal');
const revealList = document.getElementById('revealList');
const scoreList = document.getElementById('scoreList');
// DM UI
const dmTabs = document.getElementById('dmTabs');
const dmLog = document.getElementById('dmLog');
const dmInput = document.getElementById('dmInput');
const dmSendBtn = document.getElementById('dmSendBtn');

/* ---------- 점수: 세션+로컬 누적 ---------- */
let scores = {}; // id -> score (세션)
const SCORE_KEY = 'singlemafia_scores_v2';
function loadScores(){ try{ const raw=localStorage.getItem(SCORE_KEY); if(raw){ scores = JSON.parse(raw)||{}; } }catch(e){} }
function saveScores(){ try{ localStorage.setItem(SCORE_KEY, JSON.stringify(scores)); }catch(e){} }
function ensureScores(n){ for(let i=0;i<n;i++) if(scores[i]===undefined) scores[i]=0; renderScores(); }
function renderScores(){ let html=''; const ids=Object.keys(scores).map(x=>parseInt(x)).sort((a,b)=>a-b); ids.forEach(id=> html += `플레이어 ${id+1}: ${scores[id]}점<br/>`); scoreList.innerHTML = html || '-'; }
resetScoreBtn.onclick = ()=>{ if(confirm('저장된 점수를 모두 초기화할까요?')){ scores={}; saveScores(); renderScores(); } };
loadScores();
renderScores();

/* ---------- 공통 유틸 ---------- */
function log(msg,clear=false){ if(clear) messages.textContent=''; messages.textContent += msg + '\n'; messages.scrollTop = messages.scrollHeight; }
function mkBtn(label, cb){ const b=document.createElement('button'); b.textContent=label; b.onclick=cb; return b; }
function drawAvatar(container, id, role, alive){
  const size = 8, scale = 3, cvs = document.createElement('canvas');
  cvs.width = size; cvs.height = size; cvs.style.width=(size*scale)+'px'; cvs.style.height=(size*scale)+'px'; cvs.className='avatar';
  const ctx = cvs.getContext('2d'); function rnd(n){ const x = Math.sin(id*9781 + n*2654435761) * 10000; return Math.abs(x % 1); }
  const baseHue = Math.floor(rnd(1)*360);
  for(let y=0;y<size;y++)for(let x=0;x<size;x++){ const v = rnd(x*size+y)>0.5; const mafiaish = (role==='마피아'||role==='스파이'||role==='훈련사'); const hue = mafiaish?0:(role==='경찰'?210:(role==='의사'||role==='간호사'?60:180)); const c = v? `hsl(${(baseHue+hue)%360} 70% 50%)` : '#111'; ctx.fillStyle=c; ctx.fillRect(x,y,1,1); }
  if(!alive){ ctx.fillStyle='rgba(0,0,0,0.7)'; ctx.fillRect(0,0,size,size); ctx.fillStyle='rgba(255,255,255,0.9)'; ctx.font='6px monospace'; ctx.fillText('X',2,6); }
  container.appendChild(cvs);
}

/* ---------- 직업/팀 ---------- */
const TEAM = { MAFIA:'mafia', TOWN:'town', NEUTRAL:'neutral' };
const ROLES = {
  마피아:    {team:TEAM.MAFIA},
  스파이:    {team:TEAM.MAFIA},  // 접선 후 정보 공유, 단독 생존 시 공격
  훈련사:    {team:TEAM.MAFIA},  // 밤 지목 → 다음 낮+밤 봉인, 마피아 지목시 접선, 단독 생존 시 공격
  경찰:     {team:TEAM.TOWN},
  의사:     {team:TEAM.TOWN},
  간호사:   {team:TEAM.TOWN},    // 의사 사망 시 치료 승계
  판사:     {team:TEAM.TOWN},    // 낮 투표 무시 + 단독 지목 처형, 투표 면역
  정치인:   {team:TEAM.TOWN},    // 투표 2표, 투표 면역
  기자:     {team:TEAM.TOWN},    // 짝수 밤 취재 → 아침에 직업 공개
  군인:     {team:TEAM.TOWN},    // 마피아 공격 1회 방어, 경찰 사망 시 밤 1회 사격
  무당:     {team:TEAM.TOWN},    // 첫 사망자의 직업 계승
  탐정:     {team:TEAM.TOWN},    // 밤 추적 → 다음 낮 능력 사용 여부 공개
  테러범:   {team:TEAM.NEUTRAL}, // 밤에 마피아에게 피격 시 동반자폭, 낮 처형 시 무작위 1명 추가 사망
};
const SUPPORT_POOL = ['스파이','훈련사'];
const SPECIAL_POOL = ['판사','정치인','기자','군인','무당','탐정','간호사','테러범'];

/* ---------- 인원 배분 ---------- */
function buildRolesByRule(n){
  let mafiaCore=0, support=0, police=0, doctor=0;
  if(n<=5){ mafiaCore=1; support=0; police=1; doctor=1; }
  else if(n<=7){ mafiaCore=1; support=1; police=1; doctor=1; }
  else if(n===8){ mafiaCore=2; support=1; police=1; doctor=2; }
  else if(n>=9 && n<=11){ mafiaCore=2; support=1; police=1; doctor=2; }
  else { mafiaCore=3; support=1; police=1; doctor=2; }
  const roles=[];
  for(let i=0;i<mafiaCore;i++) roles.push('마피아');
  if(support>0) roles.push(SUPPORT_POOL[Math.floor(Math.random()*SUPPORT_POOL.length)]);
  for(let i=0;i<police;i++) roles.push('경찰');
  for(let i=0;i<doctor;i++) roles.push('의사');
  const pool=[...SPECIAL_POOL];
  while(roles.length<n && pool.length){ const idx=Math.floor(Math.random()*pool.length); roles.push(pool.splice(idx,1)[0]); }
  while(roles.length<n){ roles.push(SPECIAL_POOL[Math.floor(Math.random()*SPECIAL_POOL.length)]); }
  for(let i=roles.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [roles[i],roles[j]]=[roles[j],roles[i]]; }
  return roles;
}

/* ---------- 상태 ---------- */
let game=null;
function alivePlayers(){ return game.players.filter(p=>p.alive); }
function teamOf(p){ return ROLES[p.role].team; }

/* ---------- 비밀창 (DM/팀 채팅) ---------- */
// 채널 키: 'p:ID' (1:1 DM), 'team:mafia' (마피아 팀방)
let dmState = null; // { channels: {key: [{fromId,text,sys?:true,t}]}, visibleKeys:[], activeKey:'', access: Set(keys) }
function dmInit(){ dmState = { channels:{}, visibleKeys:[], activeKey:'', access:new Set() }; renderDmTabs(); renderDmLog(); }
function dmCanSee(key){ return dmState.access.has(key); }
function dmEnsure(key){ if(!dmState.channels[key]) dmState.channels[key]=[]; if(!dmState.visibleKeys.includes(key)) dmState.visibleKeys.push(key); }
function dmGrant(key){ dmState.access.add(key); dmEnsure(key); renderDmTabs(); }
function dmPost(key, fromId, text, sys=false){ dmEnsure(key); dmState.channels[key].push({fromId,text,sys,t:Date.now()}); if(dmState.activeKey===key) renderDmLog(); }
function dmSetActive(key){ if(!dmCanSee(key)) return; dmState.activeKey=key; renderDmTabs(); renderDmLog(); }
function renderDmTabs(){ dmTabs.innerHTML=''; const keys = dmState.visibleKeys.filter(k=>dmCanSee(k)); if(keys.length===0){ dmTabs.innerHTML='<span class="small">접근 가능한 비밀창이 없습니다</span>'; return; } keys.forEach(k=>{ const b=document.createElement('button'); b.className='dmTab'+(dmState.activeKey===k?' active':''); b.textContent = k.startsWith('team:')? (k==='team:mafia'?'마피아팀':'팀'): dmTabTitle(k); b.onclick=()=> dmSetActive(k); dmTabs.appendChild(b); }); }
function dmTabTitle(key){ if(!key.startsWith('p:')) return key; const id=parseInt(key.split(':')[1]); return `${id+1}번` }
function renderDmLog(){ const key=dmState.activeKey; dmLog.innerHTML=''; if(!key){ dmLog.innerHTML='<span class="small">열린 비밀창 없음</span>'; return; }
  const lines = dmState.channels[key]||[]; if(lines.length===0){ dmLog.innerHTML='<span class="small">메시지 없음</span>'; return; }
  const meId = 0;
  dmLog.innerHTML = lines.map(m=>{
    if(m.sys) return `<div class="system">[시스템] ${escapeHtml(m.text)}</div>`;
    const who = (m.fromId===meId)? '<span class="me">나</span>' : `<span class="them">${m.fromId+1}번</span>`;
    return `${who}: ${escapeHtml(m.text)}`;
  }).join('\n');
  dmLog.scrollTop = dmLog.scrollHeight;
}
function escapeHtml(s){ return (s+'').replace(/[&<>"']/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c])); }

// 플레이어가 보낼 때 (현재 액티브 채널에만)
dmSendBtn.onclick = ()=>{
  const key = dmState.activeKey; const txt = dmInput.value.trim(); if(!key||!txt) return; if(!dmCanSee(key)) return;
  dmPost(key, 0, txt, false); dmInput.value='';
  // AI는 특별한 반응은 하지 않지만, 로그는 저장됨
};

/* ---------- 렌더 ---------- */
function renderPlayers(){
  playersDiv.innerHTML='';
  game.players.forEach(p=>{
    const card=document.createElement('div'); card.className='playerCard';
    const avw=document.createElement('div'); avw.style.width='36px';
    drawAvatar(avw, p.id+11, p.role, p.alive);
    const info=document.createElement('div'); info.className='playerInfo';
    const title=document.createElement('div'); title.textContent=(p.id+1)+(p.id===0?' (당신)':'');
    const badge=document.createElement('span'); badge.className='badge'; badge.textContent=p.alive?'생존':'사망';
    title.appendChild(badge);
    const sub=document.createElement('div'); sub.className='small'; sub.style.color='#bfbfbf';
    sub.textContent=''; // ★ 의심표시(마피아 추정) 완전 비활성화
    info.appendChild(title); info.appendChild(sub);
    if(!p.alive) card.classList.add('dead');
    if(p.id===0) card.classList.add('you');
    card.appendChild(avw); card.appendChild(info);
    playersDiv.appendChild(card);
  });
}

/* ---------- 시작 ---------- */
startBtn.onclick = ()=> startGame(parseInt(playerCountSelect.value));
quickBtn.onclick = ()=>{ playerCountSelect.value=8; startGame(8); };

function startGame(n){
  const roles = buildRolesByRule(n);
  game = {
    players: roles.map((r,i)=>({ id:i, role:r, alive:true, flags:{
      soldierArmor: r==='군인', usedSoldierShot:false, // 군인
      blockedUntilDay:0, // 훈련사 봉인
    }})),
    day:0, night:0, phase:'night',
    firstDeathRole:null,
    mafiaContact: { spy:false, trainer:false },
    spyKnown: [],                // 스파이가 알게 된 정보 (id:role)
    trainerPickCount: {},        // 훈련사가 지목한 횟수 보고용 (대상별 누적)
    nightActs:{},                // 이번 밤 액션 저장
    journalistReveal:null,       // 아침 공개 텍스트
    detectiveMsg:null,           // 아침 탐정 메시지
    soldierShotAvailable:false,  // 경찰 사망 후
    suspicion: {},               // 투표 AI용 의심도 (id -> score)
    lastVotes: {},               // 지난 낮 누가 누구에게 투표했는지 (voterId -> targetId)
  };
  ensureScores(n);
  dmInit();
  // 초기에 내가 볼 수 있는 DM 채널 설정 (개인 DM 전체 표시, 내용은 시스템이 넣어줄 때만 열림)
  for(let i=1;i<n;i++){ dmGrant('p:'+i); }
  renderDmTabs(); dmSetActive('p:1');

  log(`(시작) ${n}명 게임. 직업은 비공개, 의심표시는 표시하지 않습니다.`, true);
  renderPlayers();
  setTimeout(()=> nextPhase('night'), 600);
}

function nextPhase(phase){
  game.phase=phase;
  inputSection.innerHTML='';
  if(phase==='night') nightPhase();
  else if(phase==='day') dayPhase();
  else if(phase==='end') endPhase();
}

/* ---------- NIGHT ---------- */
function canUseAbility(p){ if(!p.alive) return false; if(game.day < p.flags.blockedUntilDay) return false; return true; }
function pickRandomAlive(filterFn){ const cand = alivePlayers().filter(filterFn||(()=>true)); return cand.length? cand[Math.floor(Math.random()*cand.length)]:null; }

function nightPhase(){
  game.night++; game.nightActs = {};
  game.journalistReveal=null; game.detectiveMsg=null;
  log(`\n🌙 밤 ${game.night} 시작`);
  renderPlayers();

  if(!game.players[0].alive){ log('당신은 사망해 밤 행동 없음.'); return setTimeout(aiNightActions,700); }

  const me = game.players[0];
  const alive = alivePlayers();

  const addTargetButtons=(label,cb,filter=()=>true)=>{
    const wrap=document.createElement('div');
    wrap.innerHTML=`<div class="small">${label}</div>`;
    alive.filter(x=>x.id!==me.id && filter(x)).forEach(t=> wrap.appendChild(mkBtn((t.id+1)+'번', ()=>{ cb(t.id); inputSection.innerHTML=''; setTimeout(aiNightActions,400);})));
    inputSection.appendChild(wrap);
  };

  if(me.role==='마피아'){
    log('당신(마피아)은 공격 대상을 고르세요.');
    addTargetButtons('공격 대상', (id)=>{ game.nightActs.mafiaKill=id; log(`마피아 공격: ${id+1}번 지정.`); }, t=>teamOf(t)!==TEAM.MAFIA);
    dmGrant('team:mafia'); if(!dmState.activeKey) dmSetActive('team:mafia');
  } else if(me.role==='스파이'){
    log('당신(스파이)은 직업 탐지 대상을 고르세요. (마피아를 선택하면 접선)');
    addTargetButtons('탐지 대상', (id)=>{ game.nightActs.spyPeek=id; log(`스파이 탐지: ${id+1}번.`); });
    if(isSpySoloActive()) addTargetButtons('스파이(단독 생존) 공격 대상', (id)=>{ game.nightActs.spyKill=id; log(`스파이 단독공격: ${id+1}번.`); }, t=>t.id!==me.id);
  } else if(me.role==='훈련사'){
    log('당신(훈련사)은 다음날 낮+밤 동안 능력을 봉인할 대상을 고르세요. (마피아 지목 시 접선)');
    addTargetButtons('봉인 대상', (id)=>{ game.nightActs.trainerBlock=id; log(`훈련사 봉인: ${id+1}번.`); });
    if(isTrainerSoloActive()) addTargetButtons('훈련사(단독 생존) 개 공격 대상', (id)=>{ game.nightActs.trainerKill=id; log(`훈련사 개공격: ${id+1}번.`); });
  } else if(me.role==='의사' || (me.role==='간호사' && nurseActing())){
    log(`당신(${me.role})은 치료 대상을 고르세요.`);
    addTargetButtons('치료 대상', (id)=>{ game.nightActs.heal=id; log(`${me.role} 치료: ${id+1}번.`); });
  } else if(me.role==='경찰'){
    log('당신(경찰)은 조사 대상을 고르세요.');
    addTargetButtons('조사 대상', (id)=>{ game.nightActs.policeCheck=id; log(`경찰 조사: ${id+1}번.`); }, t=>t.id!==me.id);
  } else if(me.role==='탐정'){
    log('당신(탐정)은 추적 대상을 고르세요. (다음 낮에 능력 사용 여부 공개)');
    addTargetButtons('추적 대상', (id)=>{ game.nightActs.detectiveTrack=id; log(`탐정 추적: ${id+1}번.`); }, t=>t.id!==me.id);
  } else if(me.role==='군인' && game.soldierShotAvailable && !me.flags.usedSoldierShot){
    log('당신(군인)은 1회 사격이 가능합니다.');
    addTargetButtons('사격 대상(1회)', (id)=>{ game.nightActs.soldierShot=id; game.players[0].flags.usedSoldierShot=true; game.soldierShotAvailable=false; log(`군인 사격: ${id+1}번.`); });
  } else {
    log(`당신(${me.role})은 밤 행동 없음.`);
    setTimeout(aiNightActions, 600);
  }
}

function nurseActing(){
  const doctorAlive = game.players.some(p=>p.role==='의사' && p.alive);
  const nurse = game.players.find(p=>p.role==='간호사' && p.alive);
  return nurse && !doctorAlive;
}
function isSpySoloActive(){ const spy = game.players.find(p=>p.role==='스파이' && p.alive); if(!spy) return false; const mafiaAlive = alivePlayers().filter(p=> teamOf(p)===TEAM.MAFIA && p.role!=='스파이' && p.role!=='훈련사'); return mafiaAlive.length===0; }
function isTrainerSoloActive(){ const tr = game.players.find(p=>p.role==='훈련사' && p.alive); if(!tr) return false; const mafiaAlive = alivePlayers().filter(p=> teamOf(p)===TEAM.MAFIA && p.role!=='스파이' && p.role!=='훈련사'); return mafiaAlive.length===0; }

/* AI 밤 행동 */
function aiNightActions(){
  const alive = alivePlayers();
  const usedBy = new Set(); // 탐정용
  const addUsed = (id)=>{ if(id!=null) usedBy.add(id); };
  const A = game.nightActs;

  // 마피아 본대 공격
  if(A.mafiaKill==null){
    const mafiaSide = alive.filter(p=> teamOf(p)===TEAM.MAFIA && p.role==='마피아');
    if(mafiaSide.length){
      // 타깃 점수: 경찰>의사/간호사>판사>정치인>기타
      let best=null, bestS=-1e9;
      alive.filter(p=> teamOf(p)!==TEAM.MAFIA).forEach(c=>{
        let s= (c.role==='경찰')? 50 : (c.role==='의사'||c.role==='간호사')? 30 : (c.role==='판사')? 28 : (c.role==='정치인')? 20 : 10;
        s += (game.suspicion[c.id]||0)*0.3;
        s += Math.random()*5;
        if(s>bestS){ bestS=s; best=c; }
      });
      if(best){ A.mafiaKill=best.id; log(`AI 마피아가 ${best.id+1}번 공격을 선택.`); addUsed(mafiaSide[0].id); }
    } else {
      // 마피아 전멸 → 보조 단독 공격
      if(isSpySoloActive() && A.spyKill==null){ const t = pickRandomAlive(p=>p.role!=='스파이'); if(t){ A.spyKill=t.id; log(`AI 스파이가 단독 공격으로 ${t.id+1}번을 선택.`); addUsed(game.players.find(p=>p.role==='스파이'&&p.alive)?.id); } }
      if(isTrainerSoloActive() && A.trainerKill==null){ const t = pickRandomAlive(p=>p.role!=='훈련사'); if(t){ A.trainerKill=t.id; log(`AI 훈련사가 개공격으로 ${t.id+1}번을 선택.`); addUsed(game.players.find(p=>p.role==='훈련사'&&p.alive)?.id); } }
    }
  }

  // 스파이 탐지
  if(A.spyPeek==null){ const spy = alive.find(p=>p.role==='스파이' && p.id!==0); if(spy && canUseAbility(spy)){ const t = pickRandomAlive(p=>p.id!==spy.id); if(t){ A.spyPeek=t.id; log(`AI 스파이가 ${t.id+1}번을 탐지 대상으로 선택.`); addUsed(spy.id); } } }
  // 훈련사 봉인
  if(A.trainerBlock==null){ const tr = alive.find(p=>p.role==='훈련사' && p.id!==0); if(tr && canUseAbility(tr)){ const t = pickRandomAlive(p=>p.id!==tr.id); if(t){ A.trainerBlock=t.id; log(`AI 훈련사가 ${t.id+1}번 봉인을 선택.`); addUsed(tr.id); } } }
  // 의사/간호사 치료
  if(A.heal==null){ const doc = alive.find(p=> (p.role==='의사' || (p.role==='간호사' && nurseActing())) && p.id!==0); if(doc && canUseAbility(doc)){ const cops = alive.filter(p=>p.role==='경찰'); const pri = cops.length? cops[0]: pickRandomAlive(); if(pri){ A.heal = pri.id; log(`AI ${doc.role}가 ${pri.id+1}번 치료.`); addUsed(doc.id); } } }
  // 경찰 조사
  if(A.policeCheck==null){ const cop = alive.find(p=>p.role==='경찰' && p.id!==0); if(cop && canUseAbility(cop)){ const t = pickRandomAlive(p=>p.id!==cop.id); if(t){ A.policeCheck=t.id; log(`AI 경찰이 ${t.id+1}번을 조사.`); addUsed(cop.id);} } }
  // 군인 사격
  if(game.soldierShotAvailable && A.soldierShot==null){ const sol = alive.find(p=>p.role==='군인' && p.id!==0 && !p.flags.usedSoldierShot); if(sol){ const t = pickRandomAlive(p=>p.id!==sol.id); if(t){ A.soldierShot=t.id; sol.flags.usedSoldierShot=true; game.soldierShotAvailable=false; log(`AI 군인이 ${t.id+1}번을 사격.`); addUsed(sol.id);} } }
  // 기자 취재(짝수 밤)
  const journ = alive.find(p=>p.role==='기자'); if(journ && (game.night%2===0) && canUseAbility(journ)){ const t = pickRandomAlive(p=>p.id!==journ.id); if(t){ A.journalistTarget=t.id; addUsed(journ.id); } }
  // 탐정 추적
  if(A.detectiveTrack==null){ const det = alive.find(p=>p.role==='탐정' && p.id!==0); if(det && canUseAbility(det)){ const t = pickRandomAlive(p=>p.id!==det.id); if(t){ A.detectiveTrack=t.id; addUsed(det.id); } } }

  game._usedByThisNight = usedBy;
  setTimeout(resolveNight, 700);
}

/* 밤 해결 */
function resolveNight(){
  const A = game.nightActs; const kills = new Set(); const alive = alivePlayers();

  // 훈련사 봉인
  if(A.trainerBlock!=null){
    const trTarget = game.players[A.trainerBlock];
    if(trTarget){
      trTarget.flags.blockedUntilDay = Math.max(trTarget.flags.blockedUntilDay, game.day+1);
      game.trainerPickCount[trTarget.id] = (game.trainerPickCount[trTarget.id]||0)+1;
      // 접선 확인
      if(ROLES[trTarget.role].team===TEAM.MAFIA){
        if(!game.mafiaContact.trainer){ dmGrant('team:mafia'); }
        game.mafiaContact.trainer = true;
        dmPost('team:mafia', -1, `훈련사가 마피아(${trTarget.id+1})를 지목하여 접선 성립.`, true);
      } else if(game.mafiaContact.trainer){
        dmPost('team:mafia', -1, `훈련사 보고: ${trTarget.id+1}번을 누적 ${game.trainerPickCount[trTarget.id]}회 봉인.`, true);
      }
    }
  }

  // 스파이 탐지
  if(A.spyPeek!=null){
    const t = game.players[A.spyPeek];
    if(t){
      if(ROLES[t.role].team===TEAM.MAFIA){
        if(!game.mafiaContact.spy){ dmGrant('team:mafia'); }
        game.mafiaContact.spy = true;
        dmPost('team:mafia', -1, `스파이가 마피아(${t.id+1})와 접선했습니다.`, true);
      } else {
        const info = `${t.id+1}번은 ${t.role}`;
        game.spyKnown.push({id:t.id, role:t.role});
        if(game.mafiaContact.spy) dmPost('team:mafia', -1, `스파이 정보: ${info}`, true);
        else dmPost('p:'+t.id, -1, `스파이가 확인: ${info}`, true);
        // 의심도 보정: 마피아 아님이 확정이면 의심 하향
        if(ROLES[t.role].team!==TEAM.MAFIA) game.suspicion[t.id] = (game.suspicion[t.id]||0) - 10;
      }
    }
  }

  // 군인 사격
  if(A.soldierShot!=null){ const t = game.players[A.soldierShot]; if(t && t.alive){ kills.add(t.id); log(`밤: 군인이 ${t.id+1}번을 사격.`); } }

  // 마피아측 공격 (우선순위: 본대 > 스파이 > 훈련사)
  let attackVictim = null;
  if(A.mafiaKill!=null) attackVictim = game.players[A.mafiaKill];
  else if(A.spyKill!=null) attackVictim = game.players[A.spyKill];
  else if(A.trainerKill!=null) attackVictim = game.players[A.trainerKill];

  if(attackVictim){
    const t = attackVictim;
    if(A.heal===t.id){ log(`밤: ${t.id+1}번은 치료로 생존.`); }
    else if(t.role==='군인' && t.flags.soldierArmor){ t.flags.soldierArmor=false; log(`밤: 군인(${t.id+1})이 방탄으로 생존(회수 0).`); }
    else {
      if(t.role==='테러범'){ const maf = alivePlayers().filter(p=> teamOf(p)===TEAM.MAFIA); if(maf.length){ const m = maf[Math.floor(Math.random()*maf.length)]; kills.add(m.id); log(`밤: 테러범(${t.id+1}) 자폭으로 마피아(${m.id+1}) 동반 사망.`); } }
      kills.add(t.id); log(`밤: 공격으로 ${t.id+1}번 사망.`);
    }
  } else { log('밤: 마피아측의 공격 없음.'); }

  // 사망 처리 + 첫 사망자 → 무당 변신
  const preAlive = alivePlayers().map(p=>p.id);
  kills.forEach(id=>{ const p=game.players[id]; if(p && p.alive){ p.alive=false; if(!game.firstDeathRole) game.firstDeathRole=p.role; }});
  if(game.firstDeathRole){ const shaman = alivePlayers().find(p=>p.role==='무당'); if(shaman && !shaman.flags.morphed){ shaman.role = game.firstDeathRole; shaman.flags.morphed = true; log(`새벽: 무당이 첫 사망자의 직업(${game.firstDeathRole})으로 변했습니다.`); } }

  // 경찰 사망 여부 체크 → 군인 사격 가능
  const anyPolice = game.players.some(p=>p.role==='경찰');
  const policeAlive = alivePlayers().some(p=>p.role==='경찰');
  if(anyPolice && !policeAlive && !game._policeWasDead){ game.soldierShotAvailable=true; log(`알림: 경찰이 모두 사망. 군인이 밤에 1회 사격 가능.`); }
  game._policeWasDead = !policeAlive;

  // 기자 공개(짝수 밤)
  if(A.journalistTarget!=null){ const t = game.players[A.journalistTarget]; if(t){ game.journalistReveal = `기자: ${t.id+1}번의 직업은 ${t.role}입니다.`; if(ROLES[t.role].team===TEAM.MAFIA) game.suspicion[t.id]=(game.suspicion[t.id]||0)+35; else game.suspicion[t.id]=(game.suspicion[t.id]||0)-8; } }

  // 탐정 공개(능력 사용 여부)
  if(A.detectiveTrack!=null){ const tracked = A.detectiveTrack; const used = game._usedByThisNight && game._usedByThisNight.has(tracked); if(used){ game.detectiveMsg = `탐정: ${tracked+1}번이 전날 밤에 능력을 사용했습니다.`; game.suspicion[tracked]=(game.suspicion[tracked]||0)+6; } else { game.detectiveMsg = `탐정: ${tracked+1}번은 전날 밤에 능력을 사용하지 않았습니다.`; } }

  renderPlayers();

  if(!game.players[0].alive){ log('\n당신이 사망했습니다. 게임은 자동 진행됩니다.'); }

  if(checkWin()) return setTimeout(()=> nextPhase('end'), 900);
  setTimeout(()=> nextPhase('day'), 900);
}

/* ---------- DAY ---------- */
function dayPhase(){
  game.day++;
  log(`\n☀ 낮 ${game.day} 시작`);
  if(game.journalistReveal) log(game.journalistReveal);
  if(game.detectiveMsg) log(game.detectiveMsg);

  renderPlayers();

  const alive = alivePlayers();
  const judge = alive.find(p=>p.role==='판사');
  const playerAlive = game.players[0].alive;

  if(judge){
    log('판사가 생존: 일반 투표는 무시되며, 판사가 1명을 지목해 처형합니다. (판사/정치인은 투표로 죽지 않음)');
    if(playerAlive && game.players[0].role==='판사'){
      inputSection.innerHTML='';
      alive.filter(x=>x.id!==0).forEach(t=>{ inputSection.appendChild(mkBtn(`${t.id+1}번 처형`, ()=>{ executeByJudge(t.id); })); });
    } else {
      setTimeout(()=> aiJudgeExecute(judge.id), 900);
    }
    return;
  }

  // 일반 투표
  if(!playerAlive){
    log('당신은 죽어 투표 불가. AI가 투표를 진행합니다.');
    setTimeout(()=> aiVoteResolve(null), 800);
  } else {
    inputSection.innerHTML='<div class="small">누구를 처형할까요? (본인 제외) — 정치인/판사는 투표로 죽지 않음, 동점이면 처형 없음</div>';
    alive.filter(p=>p.id!==0).forEach(p=> inputSection.appendChild(mkBtn(`${p.id+1}번`, ()=>{ inputSection.innerHTML=''; aiVoteResolve(p.id /* 내 표 대상 */); })));
  }
}

function executeByJudge(targetId){
  const t = game.players[targetId]; if(!t || !t.alive) return; if(t.role==='판사'){ log('판사는 스스로를 처형할 수 없습니다.'); return; }
  t.alive=false; log(`낮: 판사가 ${targetId+1}번을 처형했습니다.`);
  if(t.role==='테러범'){ const r = pickRandomAlive(); if(r){ r.alive=false; log(`낮: 테러범(${t.id+1})이 무작위(${r.id+1})를 함께 사망시킴.`);} }
  renderPlayers();
  if(checkWin()) setTimeout(()=> nextPhase('end'),800); else setTimeout(()=> nextPhase('night'),800);
}
function aiJudgeExecute(judgeId){ const cand = alivePlayers().filter(p=>p.id!==judgeId); if(!cand.length) return setTimeout(()=> nextPhase('night'),600); const t = cand[Math.floor(Math.random()*cand.length)]; executeByJudge(t.id); }

/* ---------- 투표: 스마트 AI ---------- */
function candidateScoreFor(voter, target){
  if(!target.alive) return -1e9;
  if(voter.id===target.id) return -1e9;
  // 투표 면역이면 우선순위 낮춤
  const immune = (target.role==='정치인'||target.role==='판사');
  let s = 0;
  // 기본 규칙
  if(teamOf(voter)===TEAM.MAFIA){
    // 마피아는 타운/중립을 선호, 단 동원력 높은 역할 가중
    s += (teamOf(target)===TEAM.MAFIA)? -999 : 0; // 동료 배척
    s += (target.role==='경찰')? 50 : (target.role==='의사'||target.role==='간호사')? 35 : (target.role==='판사')? 40 : (target.role==='정치인')? 30 : 10;
  } else if(teamOf(voter)===TEAM.TOWN){
    // 타운은 의심도가 핵심
    s += (game.suspicion[target.id]||0);
    // 기자가 마피아라고 밝힌 경우 이미 suspicion에 반영됨
    s += (target.role==='마피아'||target.role==='스파이'||target.role==='훈련사')? 12 : 0;
  } else {
    // 중립(테러범) — 무작위성 + 강한 역할 소거 성향
    s += (target.role==='경찰'||target.role==='의사'||target.role==='판사')? 15 : 5;
  }
  // 최근 나에게 투표했던 사람에 대한 앙심 소량
  const last = Object.entries(game.lastVotes).find(([vid,tid])=> parseInt(vid)===target.id && tid===voter.id);
  if(last) s += 4;
  // 면역이면 점수 하향
  if(immune) s -= 25;
  // 소량 랜덤성
  s += Math.random()*3;
  return s;
}

function aiVoteResolve(playerVoteTarget){
  const votes = {}; const alive = alivePlayers();
  function addVote(id, weight=1){ votes[id]=(votes[id]||0)+weight; }

  // 내 표 먼저 (정치인은 2표)
  if(playerVoteTarget!=null){ addVote(playerVoteTarget, (game.players[0].role==='정치인'?2:1)); game.lastVotes[0]=playerVoteTarget; }

  // AI들 표
  alive.forEach(voter=>{
    if(voter.id===0) return;
    // 후보들 중 점수 최댓값 선택
    let bestId=null, bestS=-1e9;
    alive.forEach(target=>{
      if(target.id===voter.id) return;
      const s = candidateScoreFor(voter, target);
      if(s>bestS){ bestS=s; bestId=target.id; }
    });
    if(bestId!=null){ const w = (voter.role==='정치인'?2:1); addVote(bestId, w); game.lastVotes[voter.id]=bestId; }
  });

  // 마피아 팀은 팀 내 간단한 표 정렬(동조) — 가장 높은 득표 예상자에게 합류
  const mafiaVoters = alive.filter(p=> teamOf(p)===TEAM.MAFIA);
  if(mafiaVoters.length){
    // 득표 예측: votes 기준으로 상위 후보 산정
    let leader=null, m=0; for(const [id,c] of Object.entries(votes)){ if(c>m){ m=c; leader=parseInt(id);} }
    if(leader!=null){ mafiaVoters.forEach(mv=>{ if(game.lastVotes[mv.id]!==leader){ const w=(mv.role==='정치인'?2:1); votes[leader]=(votes[leader]||0)+w; } }); }
  }

  // 집계 출력
  log('\n투표 집계:'); Object.entries(votes).forEach(([id,c])=> log(`${parseInt(id)+1}번: ${c}표`));

  // 최다 득표자 결정
  let max=0, winners=[]; for(const [id,c] of Object.entries(votes)){ if(c>max){max=c; winners=[parseInt(id)];} else if(c===max){ winners.push(parseInt(id)); } }
  if(winners.length===1){
    const t = game.players[winners[0]];
    if(t.role==='정치인' || t.role==='판사'){ log(`낮: ${t.role}(${t.id+1})은/는 투표로 죽지 않습니다.`); }
    else {
      t.alive=false; log(`낮: ${t.id+1}번이 처형되었습니다.`);
      // 테러범 낮 자폭
      if(t.role==='테러범'){ const r = pickRandomAlive(); if(r){ r.alive=false; log(`낮: 테러범(${t.id+1})이 무작위(${r.id+1})와 동반사망.`);} }
      // 처형된 대상이 마피아측이면 의심도 하향 보정, 타운이면 반대로 약간 증가 (학습 느낌)
      const isM = (teamOf(t)===TEAM.MAFIA); alivePlayers().forEach(p=>{ if(p.id!==t.id) game.suspicion[p.id] = (game.suspicion[p.id]||0) + (isM?-2:1); });
    }
  } else { log('낮: 동점/무효로 처형 없음.'); }

  renderPlayers();
  if(checkWin()) setTimeout(()=> nextPhase('end'),900); else setTimeout(()=> nextPhase('night'),900);
}

/* ---------- 승리/종료/점수 ---------- */
function checkWin(){
  const alive = alivePlayers();
  const mafiaAlive = alive.filter(p=> teamOf(p)===TEAM.MAFIA).length;
  const townAlive = alive.filter(p=> teamOf(p)===TEAM.TOWN).length;
  if(mafiaAlive===0){ log('\n🎉 타운 승리!'); applyScores('town'); return true; }
  if(mafiaAlive >= townAlive && mafiaAlive>0){ log('\n💀 마피아 승리!'); applyScores('mafia'); return true; }
  return false;
}
function applyScores(winner){
  game.players.forEach(p=>{ const team = teamOf(p); if(scores[p.id]===undefined) scores[p.id]=0; if(team===winner) scores[p.id]+=10; else scores[p.id]-=2; });
  renderScores(); saveScores();
}
function endPhase(){
  log('\n=== 게임 종료 — 역할 공개 ===');
  revealBox.style.display='block';
  let html=''; game.players.forEach(p=>{ html += `${p.id+1}번: ${p.role} (${p.alive?'생존':'사망'})<br/>`; });
  revealList.innerHTML = html;
  inputSection.innerHTML = '<div class="warn">다시 시작하려면 아래 버튼을 누르세요.</div><div style="text-align:center"><button id="restart">다시 시작</button></div>';
  document.getElementById('restart').onclick = ()=> location.reload();
  renderPlayers();
}

// 초기 점수 보이기
renderScores();

</script></body>
</html>
